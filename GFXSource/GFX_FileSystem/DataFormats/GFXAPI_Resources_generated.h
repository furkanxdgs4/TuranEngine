// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GFXAPIRESOURCES_GFXASSET_H_
#define FLATBUFFERS_GENERATED_GFXAPIRESOURCES_GFXASSET_H_

#include "flatbuffers/flatbuffers.h"

namespace GFXAsset {

struct Vec3;

struct Vec2;

struct Vec4;

struct Mat4x4;

struct UNIFORM_UINT32;

struct UNIFORM_INT32;

struct UNIFORM_FLOAT;

struct UNIFORM_VEC2;

struct UNIFORM_VEC3;

struct UNIFORM_VEC4;

struct UNIFORM_MAT4x4;

struct UNIFORM_TEXTURE2D;

struct MATERIAL_INSTANCE_UNIFORM_TABLE;

struct SHADERSOURCE;

struct MATERIAL_TYPE;

struct MATERIAL_INSTANCE;

struct TEXTURE;

struct Resource;

enum GFX_APIs {
  GFX_APIs_OPENGL4 = 0,
  GFX_APIs_VULKAN = 1,
  GFX_APIs_MIN = GFX_APIs_OPENGL4,
  GFX_APIs_MAX = GFX_APIs_VULKAN
};

inline const GFX_APIs (&EnumValuesGFX_APIs())[2] {
  static const GFX_APIs values[] = {
    GFX_APIs_OPENGL4,
    GFX_APIs_VULKAN
  };
  return values;
}

inline const char * const *EnumNamesGFX_APIs() {
  static const char * const names[3] = {
    "OPENGL4",
    "VULKAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameGFX_APIs(GFX_APIs e) {
  if (e < GFX_APIs_OPENGL4 || e > GFX_APIs_VULKAN) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGFX_APIs()[index];
}

enum SHADER_LANGUAGES {
  SHADER_LANGUAGES_GLSL = 0,
  SHADER_LANGUAGES_HLSL = 1,
  SHADER_LANGUAGES_SPIRV = 2,
  SHADER_LANGUAGES_TSL = 3,
  SHADER_LANGUAGES_MIN = SHADER_LANGUAGES_GLSL,
  SHADER_LANGUAGES_MAX = SHADER_LANGUAGES_TSL
};

inline const SHADER_LANGUAGES (&EnumValuesSHADER_LANGUAGES())[4] {
  static const SHADER_LANGUAGES values[] = {
    SHADER_LANGUAGES_GLSL,
    SHADER_LANGUAGES_HLSL,
    SHADER_LANGUAGES_SPIRV,
    SHADER_LANGUAGES_TSL
  };
  return values;
}

inline const char * const *EnumNamesSHADER_LANGUAGES() {
  static const char * const names[5] = {
    "GLSL",
    "HLSL",
    "SPIRV",
    "TSL",
    nullptr
  };
  return names;
}

inline const char *EnumNameSHADER_LANGUAGES(SHADER_LANGUAGES e) {
  if (e < SHADER_LANGUAGES_GLSL || e > SHADER_LANGUAGES_TSL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSHADER_LANGUAGES()[index];
}

enum MATERIAL_INSTANCE_UNIFORM {
  MATERIAL_INSTANCE_UNIFORM_NONE = 0,
  MATERIAL_INSTANCE_UNIFORM_UINT32 = 1,
  MATERIAL_INSTANCE_UNIFORM_INT32 = 2,
  MATERIAL_INSTANCE_UNIFORM_FLOAT = 3,
  MATERIAL_INSTANCE_UNIFORM_VEC2 = 4,
  MATERIAL_INSTANCE_UNIFORM_VEC3 = 5,
  MATERIAL_INSTANCE_UNIFORM_VEC4 = 6,
  MATERIAL_INSTANCE_UNIFORM_Mat4x4 = 7,
  MATERIAL_INSTANCE_UNIFORM_TEXTURE2D = 8,
  MATERIAL_INSTANCE_UNIFORM_MIN = MATERIAL_INSTANCE_UNIFORM_NONE,
  MATERIAL_INSTANCE_UNIFORM_MAX = MATERIAL_INSTANCE_UNIFORM_TEXTURE2D
};

inline const MATERIAL_INSTANCE_UNIFORM (&EnumValuesMATERIAL_INSTANCE_UNIFORM())[9] {
  static const MATERIAL_INSTANCE_UNIFORM values[] = {
    MATERIAL_INSTANCE_UNIFORM_NONE,
    MATERIAL_INSTANCE_UNIFORM_UINT32,
    MATERIAL_INSTANCE_UNIFORM_INT32,
    MATERIAL_INSTANCE_UNIFORM_FLOAT,
    MATERIAL_INSTANCE_UNIFORM_VEC2,
    MATERIAL_INSTANCE_UNIFORM_VEC3,
    MATERIAL_INSTANCE_UNIFORM_VEC4,
    MATERIAL_INSTANCE_UNIFORM_Mat4x4,
    MATERIAL_INSTANCE_UNIFORM_TEXTURE2D
  };
  return values;
}

inline const char * const *EnumNamesMATERIAL_INSTANCE_UNIFORM() {
  static const char * const names[10] = {
    "NONE",
    "UINT32",
    "INT32",
    "FLOAT",
    "VEC2",
    "VEC3",
    "VEC4",
    "Mat4x4",
    "TEXTURE2D",
    nullptr
  };
  return names;
}

inline const char *EnumNameMATERIAL_INSTANCE_UNIFORM(MATERIAL_INSTANCE_UNIFORM e) {
  if (e < MATERIAL_INSTANCE_UNIFORM_NONE || e > MATERIAL_INSTANCE_UNIFORM_TEXTURE2D) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMATERIAL_INSTANCE_UNIFORM()[index];
}

template<typename T> struct MATERIAL_INSTANCE_UNIFORMTraits {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_NONE;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_UINT32> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_UINT32;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_INT32> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_INT32;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_FLOAT> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_FLOAT;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_VEC2> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_VEC2;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_VEC3> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_VEC3;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_VEC4> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_VEC4;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_MAT4x4> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_Mat4x4;
};

template<> struct MATERIAL_INSTANCE_UNIFORMTraits<GFXAsset::UNIFORM_TEXTURE2D> {
  static const MATERIAL_INSTANCE_UNIFORM enum_value = MATERIAL_INSTANCE_UNIFORM_TEXTURE2D;
};

bool VerifyMATERIAL_INSTANCE_UNIFORM(flatbuffers::Verifier &verifier, const void *obj, MATERIAL_INSTANCE_UNIFORM type);
bool VerifyMATERIAL_INSTANCE_UNIFORMVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum SHADERSTAGEs {
  SHADERSTAGEs_VERTEX_STAGE = 0,
  SHADERSTAGEs_FRAGMENT_STAGE = 1,
  SHADERSTAGEs_COMPUTE = 2,
  SHADERSTAGEs_MIN = SHADERSTAGEs_VERTEX_STAGE,
  SHADERSTAGEs_MAX = SHADERSTAGEs_COMPUTE
};

inline const SHADERSTAGEs (&EnumValuesSHADERSTAGEs())[3] {
  static const SHADERSTAGEs values[] = {
    SHADERSTAGEs_VERTEX_STAGE,
    SHADERSTAGEs_FRAGMENT_STAGE,
    SHADERSTAGEs_COMPUTE
  };
  return values;
}

inline const char * const *EnumNamesSHADERSTAGEs() {
  static const char * const names[4] = {
    "VERTEX_STAGE",
    "FRAGMENT_STAGE",
    "COMPUTE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSHADERSTAGEs(SHADERSTAGEs e) {
  if (e < SHADERSTAGEs_VERTEX_STAGE || e > SHADERSTAGEs_COMPUTE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSHADERSTAGEs()[index];
}

enum TEXTURE_DIMENSION {
  TEXTURE_DIMENSION_TEXTURE_2D = 0,
  TEXTURE_DIMENSION_MIN = TEXTURE_DIMENSION_TEXTURE_2D,
  TEXTURE_DIMENSION_MAX = TEXTURE_DIMENSION_TEXTURE_2D
};

inline const TEXTURE_DIMENSION (&EnumValuesTEXTURE_DIMENSION())[1] {
  static const TEXTURE_DIMENSION values[] = {
    TEXTURE_DIMENSION_TEXTURE_2D
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_DIMENSION() {
  static const char * const names[2] = {
    "TEXTURE_2D",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_DIMENSION(TEXTURE_DIMENSION e) {
  if (e < TEXTURE_DIMENSION_TEXTURE_2D || e > TEXTURE_DIMENSION_TEXTURE_2D) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_DIMENSION()[index];
}

enum TEXTURE_CHANNELs {
  TEXTURE_CHANNELs_TEXTURE_RGB = 0,
  TEXTURE_CHANNELs_TEXTURE_RGBA = 1,
  TEXTURE_CHANNELs_TEXTURE_DEPTH = 2,
  TEXTURE_CHANNELs_MIN = TEXTURE_CHANNELs_TEXTURE_RGB,
  TEXTURE_CHANNELs_MAX = TEXTURE_CHANNELs_TEXTURE_DEPTH
};

inline const TEXTURE_CHANNELs (&EnumValuesTEXTURE_CHANNELs())[3] {
  static const TEXTURE_CHANNELs values[] = {
    TEXTURE_CHANNELs_TEXTURE_RGB,
    TEXTURE_CHANNELs_TEXTURE_RGBA,
    TEXTURE_CHANNELs_TEXTURE_DEPTH
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_CHANNELs() {
  static const char * const names[4] = {
    "TEXTURE_RGB",
    "TEXTURE_RGBA",
    "TEXTURE_DEPTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_CHANNELs(TEXTURE_CHANNELs e) {
  if (e < TEXTURE_CHANNELs_TEXTURE_RGB || e > TEXTURE_CHANNELs_TEXTURE_DEPTH) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_CHANNELs()[index];
}

enum TEXTURE_MIPMAP_FILTERING {
  TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP = 0,
  TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_2MIP = 1,
  TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_1MIP = 2,
  TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP = 3,
  TEXTURE_MIPMAP_FILTERING_MIN = TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
  TEXTURE_MIPMAP_FILTERING_MAX = TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP
};

inline const TEXTURE_MIPMAP_FILTERING (&EnumValuesTEXTURE_MIPMAP_FILTERING())[4] {
  static const TEXTURE_MIPMAP_FILTERING values[] = {
    TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
    TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_2MIP,
    TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_1MIP,
    TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_MIPMAP_FILTERING() {
  static const char * const names[5] = {
    "LINEAR_FROM_1MIP",
    "LINEAR_FROM_2MIP",
    "NEAREST_FROM_1MIP",
    "NEAREST_FROM_2MIP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_MIPMAP_FILTERING(TEXTURE_MIPMAP_FILTERING e) {
  if (e < TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP || e > TEXTURE_MIPMAP_FILTERING_NEAREST_FROM_2MIP) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_MIPMAP_FILTERING()[index];
}

enum TEXTURE_WRAPPING {
  TEXTURE_WRAPPING_REPEAT = 0,
  TEXTURE_WRAPPING_MIRRORED_REPEAT = 1,
  TEXTURE_WRAPPING_CLAMP_TO_EDGE = 2,
  TEXTURE_WRAPPING_MIN = TEXTURE_WRAPPING_REPEAT,
  TEXTURE_WRAPPING_MAX = TEXTURE_WRAPPING_CLAMP_TO_EDGE
};

inline const TEXTURE_WRAPPING (&EnumValuesTEXTURE_WRAPPING())[3] {
  static const TEXTURE_WRAPPING values[] = {
    TEXTURE_WRAPPING_REPEAT,
    TEXTURE_WRAPPING_MIRRORED_REPEAT,
    TEXTURE_WRAPPING_CLAMP_TO_EDGE
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_WRAPPING() {
  static const char * const names[4] = {
    "REPEAT",
    "MIRRORED_REPEAT",
    "CLAMP_TO_EDGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_WRAPPING(TEXTURE_WRAPPING e) {
  if (e < TEXTURE_WRAPPING_REPEAT || e > TEXTURE_WRAPPING_CLAMP_TO_EDGE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_WRAPPING()[index];
}

enum TEXTURE_VALUETYPE {
  TEXTURE_VALUETYPE_UBYTE8 = 0,
  TEXTURE_VALUETYPE_BYTE8 = 1,
  TEXTURE_VALUETYPE_UINT32 = 2,
  TEXTURE_VALUETYPE_INT32 = 3,
  TEXTURE_VALUETYPE_FLOAT32 = 4,
  TEXTURE_VALUETYPE_MIN = TEXTURE_VALUETYPE_UBYTE8,
  TEXTURE_VALUETYPE_MAX = TEXTURE_VALUETYPE_FLOAT32
};

inline const TEXTURE_VALUETYPE (&EnumValuesTEXTURE_VALUETYPE())[5] {
  static const TEXTURE_VALUETYPE values[] = {
    TEXTURE_VALUETYPE_UBYTE8,
    TEXTURE_VALUETYPE_BYTE8,
    TEXTURE_VALUETYPE_UINT32,
    TEXTURE_VALUETYPE_INT32,
    TEXTURE_VALUETYPE_FLOAT32
  };
  return values;
}

inline const char * const *EnumNamesTEXTURE_VALUETYPE() {
  static const char * const names[6] = {
    "UBYTE8",
    "BYTE8",
    "UINT32",
    "INT32",
    "FLOAT32",
    nullptr
  };
  return names;
}

inline const char *EnumNameTEXTURE_VALUETYPE(TEXTURE_VALUETYPE e) {
  if (e < TEXTURE_VALUETYPE_UBYTE8 || e > TEXTURE_VALUETYPE_FLOAT32) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTEXTURE_VALUETYPE()[index];
}

enum Resource_Type {
  Resource_Type_NONE = 0,
  Resource_Type_Shader_Source = 1,
  Resource_Type_Material_Type = 2,
  Resource_Type_Material_Instance = 3,
  Resource_Type_Texture = 4,
  Resource_Type_MIN = Resource_Type_NONE,
  Resource_Type_MAX = Resource_Type_Texture
};

inline const Resource_Type (&EnumValuesResource_Type())[5] {
  static const Resource_Type values[] = {
    Resource_Type_NONE,
    Resource_Type_Shader_Source,
    Resource_Type_Material_Type,
    Resource_Type_Material_Instance,
    Resource_Type_Texture
  };
  return values;
}

inline const char * const *EnumNamesResource_Type() {
  static const char * const names[6] = {
    "NONE",
    "Shader_Source",
    "Material_Type",
    "Material_Instance",
    "Texture",
    nullptr
  };
  return names;
}

inline const char *EnumNameResource_Type(Resource_Type e) {
  if (e < Resource_Type_NONE || e > Resource_Type_Texture) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResource_Type()[index];
}

template<typename T> struct Resource_TypeTraits {
  static const Resource_Type enum_value = Resource_Type_NONE;
};

template<> struct Resource_TypeTraits<GFXAsset::SHADERSOURCE> {
  static const Resource_Type enum_value = Resource_Type_Shader_Source;
};

template<> struct Resource_TypeTraits<GFXAsset::MATERIAL_TYPE> {
  static const Resource_Type enum_value = Resource_Type_Material_Type;
};

template<> struct Resource_TypeTraits<GFXAsset::MATERIAL_INSTANCE> {
  static const Resource_Type enum_value = Resource_Type_Material_Instance;
};

template<> struct Resource_TypeTraits<GFXAsset::TEXTURE> {
  static const Resource_Type enum_value = Resource_Type_Texture;
};

bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type);
bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4x4 FLATBUFFERS_FINAL_CLASS {
 private:
  GFXAsset::Vec4 ROW_1_;
  GFXAsset::Vec4 ROW_2_;
  GFXAsset::Vec4 ROW_3_;
  GFXAsset::Vec4 ROW_4_;

 public:
  Mat4x4() {
    memset(static_cast<void *>(this), 0, sizeof(Mat4x4));
  }
  Mat4x4(const GFXAsset::Vec4 &_ROW_1, const GFXAsset::Vec4 &_ROW_2, const GFXAsset::Vec4 &_ROW_3, const GFXAsset::Vec4 &_ROW_4)
      : ROW_1_(_ROW_1),
        ROW_2_(_ROW_2),
        ROW_3_(_ROW_3),
        ROW_4_(_ROW_4) {
  }
  const GFXAsset::Vec4 &ROW_1() const {
    return ROW_1_;
  }
  const GFXAsset::Vec4 &ROW_2() const {
    return ROW_2_;
  }
  const GFXAsset::Vec4 &ROW_3() const {
    return ROW_3_;
  }
  const GFXAsset::Vec4 &ROW_4() const {
    return ROW_4_;
  }
};
FLATBUFFERS_STRUCT_END(Mat4x4, 64);

struct UNIFORM_UINT32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t DATA() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint32_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_UINT32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_UINT32::VT_NAME, NAME);
  }
  void add_DATA(uint32_t DATA) {
    fbb_.AddElement<uint32_t>(UNIFORM_UINT32::VT_DATA, DATA, 0);
  }
  explicit UNIFORM_UINT32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_UINT32Builder &operator=(const UNIFORM_UINT32Builder &);
  flatbuffers::Offset<UNIFORM_UINT32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_UINT32>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_UINT32> CreateUNIFORM_UINT32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    uint32_t DATA = 0) {
  UNIFORM_UINT32Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_UINT32> CreateUNIFORM_UINT32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint32_t DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_UINT32(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_INT32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t DATA() const {
    return GetField<int32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<int32_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_INT32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_INT32::VT_NAME, NAME);
  }
  void add_DATA(int32_t DATA) {
    fbb_.AddElement<int32_t>(UNIFORM_INT32::VT_DATA, DATA, 0);
  }
  explicit UNIFORM_INT32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_INT32Builder &operator=(const UNIFORM_INT32Builder &);
  flatbuffers::Offset<UNIFORM_INT32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_INT32>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_INT32> CreateUNIFORM_INT32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    int32_t DATA = 0) {
  UNIFORM_INT32Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_INT32> CreateUNIFORM_INT32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    int32_t DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_INT32(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_FLOAT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float DATA() const {
    return GetField<float>(VT_DATA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<float>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_FLOATBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_FLOAT::VT_NAME, NAME);
  }
  void add_DATA(float DATA) {
    fbb_.AddElement<float>(UNIFORM_FLOAT::VT_DATA, DATA, 0.0f);
  }
  explicit UNIFORM_FLOATBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_FLOATBuilder &operator=(const UNIFORM_FLOATBuilder &);
  flatbuffers::Offset<UNIFORM_FLOAT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_FLOAT>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_FLOAT> CreateUNIFORM_FLOAT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    float DATA = 0.0f) {
  UNIFORM_FLOATBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_FLOAT> CreateUNIFORM_FLOATDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    float DATA = 0.0f) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_FLOAT(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_VEC2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GFXAsset::Vec2 *DATA() const {
    return GetStruct<const GFXAsset::Vec2 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GFXAsset::Vec2>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_VEC2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_VEC2::VT_NAME, NAME);
  }
  void add_DATA(const GFXAsset::Vec2 *DATA) {
    fbb_.AddStruct(UNIFORM_VEC2::VT_DATA, DATA);
  }
  explicit UNIFORM_VEC2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_VEC2Builder &operator=(const UNIFORM_VEC2Builder &);
  flatbuffers::Offset<UNIFORM_VEC2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_VEC2>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_VEC2> CreateUNIFORM_VEC2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GFXAsset::Vec2 *DATA = 0) {
  UNIFORM_VEC2Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_VEC2> CreateUNIFORM_VEC2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GFXAsset::Vec2 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_VEC2(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_VEC3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GFXAsset::Vec3 *DATA() const {
    return GetStruct<const GFXAsset::Vec3 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GFXAsset::Vec3>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_VEC3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_VEC3::VT_NAME, NAME);
  }
  void add_DATA(const GFXAsset::Vec3 *DATA) {
    fbb_.AddStruct(UNIFORM_VEC3::VT_DATA, DATA);
  }
  explicit UNIFORM_VEC3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_VEC3Builder &operator=(const UNIFORM_VEC3Builder &);
  flatbuffers::Offset<UNIFORM_VEC3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_VEC3>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_VEC3> CreateUNIFORM_VEC3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GFXAsset::Vec3 *DATA = 0) {
  UNIFORM_VEC3Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_VEC3> CreateUNIFORM_VEC3Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GFXAsset::Vec3 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_VEC3(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_VEC4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GFXAsset::Vec4 *DATA() const {
    return GetStruct<const GFXAsset::Vec4 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GFXAsset::Vec4>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_VEC4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_VEC4::VT_NAME, NAME);
  }
  void add_DATA(const GFXAsset::Vec4 *DATA) {
    fbb_.AddStruct(UNIFORM_VEC4::VT_DATA, DATA);
  }
  explicit UNIFORM_VEC4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_VEC4Builder &operator=(const UNIFORM_VEC4Builder &);
  flatbuffers::Offset<UNIFORM_VEC4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_VEC4>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_VEC4> CreateUNIFORM_VEC4(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GFXAsset::Vec4 *DATA = 0) {
  UNIFORM_VEC4Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_VEC4> CreateUNIFORM_VEC4Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GFXAsset::Vec4 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_VEC4(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_MAT4x4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const GFXAsset::Mat4x4 *DATA() const {
    return GetStruct<const GFXAsset::Mat4x4 *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<GFXAsset::Mat4x4>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_MAT4x4Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_MAT4x4::VT_NAME, NAME);
  }
  void add_DATA(const GFXAsset::Mat4x4 *DATA) {
    fbb_.AddStruct(UNIFORM_MAT4x4::VT_DATA, DATA);
  }
  explicit UNIFORM_MAT4x4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_MAT4x4Builder &operator=(const UNIFORM_MAT4x4Builder &);
  flatbuffers::Offset<UNIFORM_MAT4x4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_MAT4x4>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_MAT4x4> CreateUNIFORM_MAT4x4(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const GFXAsset::Mat4x4 *DATA = 0) {
  UNIFORM_MAT4x4Builder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_MAT4x4> CreateUNIFORM_MAT4x4Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const GFXAsset::Mat4x4 *DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_MAT4x4(
      _fbb,
      NAME__,
      DATA);
}

struct UNIFORM_TEXTURE2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t DATA() const {
    return GetField<uint32_t>(VT_DATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint32_t>(verifier, VT_DATA) &&
           verifier.EndTable();
  }
};

struct UNIFORM_TEXTURE2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(UNIFORM_TEXTURE2D::VT_NAME, NAME);
  }
  void add_DATA(uint32_t DATA) {
    fbb_.AddElement<uint32_t>(UNIFORM_TEXTURE2D::VT_DATA, DATA, 0);
  }
  explicit UNIFORM_TEXTURE2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNIFORM_TEXTURE2DBuilder &operator=(const UNIFORM_TEXTURE2DBuilder &);
  flatbuffers::Offset<UNIFORM_TEXTURE2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNIFORM_TEXTURE2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNIFORM_TEXTURE2D> CreateUNIFORM_TEXTURE2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    uint32_t DATA = 0) {
  UNIFORM_TEXTURE2DBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNIFORM_TEXTURE2D> CreateUNIFORM_TEXTURE2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint32_t DATA = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return GFXAsset::CreateUNIFORM_TEXTURE2D(
      _fbb,
      NAME__,
      DATA);
}

struct MATERIAL_INSTANCE_UNIFORM_TABLE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIFORM_TYPE = 4,
    VT_UNIFORM = 6
  };
  GFXAsset::MATERIAL_INSTANCE_UNIFORM UNIFORM_type() const {
    return static_cast<GFXAsset::MATERIAL_INSTANCE_UNIFORM>(GetField<uint8_t>(VT_UNIFORM_TYPE, 0));
  }
  const void *UNIFORM() const {
    return GetPointer<const void *>(VT_UNIFORM);
  }
  template<typename T> const T *UNIFORM_as() const;
  const GFXAsset::UNIFORM_UINT32 *UNIFORM_as_UINT32() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_UINT32 ? static_cast<const GFXAsset::UNIFORM_UINT32 *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_INT32 *UNIFORM_as_INT32() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_INT32 ? static_cast<const GFXAsset::UNIFORM_INT32 *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_FLOAT *UNIFORM_as_FLOAT() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_FLOAT ? static_cast<const GFXAsset::UNIFORM_FLOAT *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_VEC2 *UNIFORM_as_VEC2() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_VEC2 ? static_cast<const GFXAsset::UNIFORM_VEC2 *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_VEC3 *UNIFORM_as_VEC3() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_VEC3 ? static_cast<const GFXAsset::UNIFORM_VEC3 *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_VEC4 *UNIFORM_as_VEC4() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_VEC4 ? static_cast<const GFXAsset::UNIFORM_VEC4 *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_MAT4x4 *UNIFORM_as_Mat4x4() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_Mat4x4 ? static_cast<const GFXAsset::UNIFORM_MAT4x4 *>(UNIFORM()) : nullptr;
  }
  const GFXAsset::UNIFORM_TEXTURE2D *UNIFORM_as_TEXTURE2D() const {
    return UNIFORM_type() == GFXAsset::MATERIAL_INSTANCE_UNIFORM_TEXTURE2D ? static_cast<const GFXAsset::UNIFORM_TEXTURE2D *>(UNIFORM()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNIFORM_TYPE) &&
           VerifyOffset(verifier, VT_UNIFORM) &&
           VerifyMATERIAL_INSTANCE_UNIFORM(verifier, UNIFORM(), UNIFORM_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GFXAsset::UNIFORM_UINT32 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_UINT32>() const {
  return UNIFORM_as_UINT32();
}

template<> inline const GFXAsset::UNIFORM_INT32 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_INT32>() const {
  return UNIFORM_as_INT32();
}

template<> inline const GFXAsset::UNIFORM_FLOAT *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_FLOAT>() const {
  return UNIFORM_as_FLOAT();
}

template<> inline const GFXAsset::UNIFORM_VEC2 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_VEC2>() const {
  return UNIFORM_as_VEC2();
}

template<> inline const GFXAsset::UNIFORM_VEC3 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_VEC3>() const {
  return UNIFORM_as_VEC3();
}

template<> inline const GFXAsset::UNIFORM_VEC4 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_VEC4>() const {
  return UNIFORM_as_VEC4();
}

template<> inline const GFXAsset::UNIFORM_MAT4x4 *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_MAT4x4>() const {
  return UNIFORM_as_Mat4x4();
}

template<> inline const GFXAsset::UNIFORM_TEXTURE2D *MATERIAL_INSTANCE_UNIFORM_TABLE::UNIFORM_as<GFXAsset::UNIFORM_TEXTURE2D>() const {
  return UNIFORM_as_TEXTURE2D();
}

struct MATERIAL_INSTANCE_UNIFORM_TABLEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_UNIFORM_type(GFXAsset::MATERIAL_INSTANCE_UNIFORM UNIFORM_type) {
    fbb_.AddElement<uint8_t>(MATERIAL_INSTANCE_UNIFORM_TABLE::VT_UNIFORM_TYPE, static_cast<uint8_t>(UNIFORM_type), 0);
  }
  void add_UNIFORM(flatbuffers::Offset<void> UNIFORM) {
    fbb_.AddOffset(MATERIAL_INSTANCE_UNIFORM_TABLE::VT_UNIFORM, UNIFORM);
  }
  explicit MATERIAL_INSTANCE_UNIFORM_TABLEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_INSTANCE_UNIFORM_TABLEBuilder &operator=(const MATERIAL_INSTANCE_UNIFORM_TABLEBuilder &);
  flatbuffers::Offset<MATERIAL_INSTANCE_UNIFORM_TABLE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_INSTANCE_UNIFORM_TABLE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_INSTANCE_UNIFORM_TABLE> CreateMATERIAL_INSTANCE_UNIFORM_TABLE(
    flatbuffers::FlatBufferBuilder &_fbb,
    GFXAsset::MATERIAL_INSTANCE_UNIFORM UNIFORM_type = GFXAsset::MATERIAL_INSTANCE_UNIFORM_NONE,
    flatbuffers::Offset<void> UNIFORM = 0) {
  MATERIAL_INSTANCE_UNIFORM_TABLEBuilder builder_(_fbb);
  builder_.add_UNIFORM(UNIFORM);
  builder_.add_UNIFORM_type(UNIFORM_type);
  return builder_.Finish();
}

struct SHADERSOURCE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE = 4,
    VT_CODE = 6,
    VT_LANGUAGE = 8
  };
  GFXAsset::SHADERSTAGEs STAGE() const {
    return static_cast<GFXAsset::SHADERSTAGEs>(GetField<uint8_t>(VT_STAGE, 0));
  }
  const flatbuffers::String *CODE() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  GFXAsset::SHADER_LANGUAGES LANGUAGE() const {
    return static_cast<GFXAsset::SHADER_LANGUAGES>(GetField<uint8_t>(VT_LANGUAGE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STAGE) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(CODE()) &&
           VerifyField<uint8_t>(verifier, VT_LANGUAGE) &&
           verifier.EndTable();
  }
};

struct SHADERSOURCEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_STAGE(GFXAsset::SHADERSTAGEs STAGE) {
    fbb_.AddElement<uint8_t>(SHADERSOURCE::VT_STAGE, static_cast<uint8_t>(STAGE), 0);
  }
  void add_CODE(flatbuffers::Offset<flatbuffers::String> CODE) {
    fbb_.AddOffset(SHADERSOURCE::VT_CODE, CODE);
  }
  void add_LANGUAGE(GFXAsset::SHADER_LANGUAGES LANGUAGE) {
    fbb_.AddElement<uint8_t>(SHADERSOURCE::VT_LANGUAGE, static_cast<uint8_t>(LANGUAGE), 0);
  }
  explicit SHADERSOURCEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHADERSOURCEBuilder &operator=(const SHADERSOURCEBuilder &);
  flatbuffers::Offset<SHADERSOURCE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHADERSOURCE>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHADERSOURCE> CreateSHADERSOURCE(
    flatbuffers::FlatBufferBuilder &_fbb,
    GFXAsset::SHADERSTAGEs STAGE = GFXAsset::SHADERSTAGEs_VERTEX_STAGE,
    flatbuffers::Offset<flatbuffers::String> CODE = 0,
    GFXAsset::SHADER_LANGUAGES LANGUAGE = GFXAsset::SHADER_LANGUAGES_GLSL) {
  SHADERSOURCEBuilder builder_(_fbb);
  builder_.add_CODE(CODE);
  builder_.add_LANGUAGE(LANGUAGE);
  builder_.add_STAGE(STAGE);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHADERSOURCE> CreateSHADERSOURCEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GFXAsset::SHADERSTAGEs STAGE = GFXAsset::SHADERSTAGEs_VERTEX_STAGE,
    const char *CODE = nullptr,
    GFXAsset::SHADER_LANGUAGES LANGUAGE = GFXAsset::SHADER_LANGUAGES_GLSL) {
  auto CODE__ = CODE ? _fbb.CreateString(CODE) : 0;
  return GFXAsset::CreateSHADERSOURCE(
      _fbb,
      STAGE,
      CODE__,
      LANGUAGE);
}

struct MATERIAL_TYPE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGES = 4,
    VT_MATERIAL_INPUTS = 6
  };
  const flatbuffers::Vector<uint32_t> *STAGEs() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_STAGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>> *MATERIAL_INPUTs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>> *>(VT_MATERIAL_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STAGES) &&
           verifier.VerifyVector(STAGEs()) &&
           VerifyOffset(verifier, VT_MATERIAL_INPUTS) &&
           verifier.VerifyVector(MATERIAL_INPUTs()) &&
           verifier.VerifyVectorOfTables(MATERIAL_INPUTs()) &&
           verifier.EndTable();
  }
};

struct MATERIAL_TYPEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_STAGEs(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> STAGEs) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_STAGES, STAGEs);
  }
  void add_MATERIAL_INPUTs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>>> MATERIAL_INPUTs) {
    fbb_.AddOffset(MATERIAL_TYPE::VT_MATERIAL_INPUTS, MATERIAL_INPUTs);
  }
  explicit MATERIAL_TYPEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_TYPEBuilder &operator=(const MATERIAL_TYPEBuilder &);
  flatbuffers::Offset<MATERIAL_TYPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_TYPE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_TYPE> CreateMATERIAL_TYPE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> STAGEs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>>> MATERIAL_INPUTs = 0) {
  MATERIAL_TYPEBuilder builder_(_fbb);
  builder_.add_MATERIAL_INPUTs(MATERIAL_INPUTs);
  builder_.add_STAGEs(STAGEs);
  return builder_.Finish();
}

inline flatbuffers::Offset<MATERIAL_TYPE> CreateMATERIAL_TYPEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *STAGEs = nullptr,
    const std::vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>> *MATERIAL_INPUTs = nullptr) {
  auto STAGEs__ = STAGEs ? _fbb.CreateVector<uint32_t>(*STAGEs) : 0;
  auto MATERIAL_INPUTs__ = MATERIAL_INPUTs ? _fbb.CreateVector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>>(*MATERIAL_INPUTs) : 0;
  return GFXAsset::CreateMATERIAL_TYPE(
      _fbb,
      STAGEs__,
      MATERIAL_INPUTs__);
}

struct MATERIAL_INSTANCE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL_TYPE_ID = 4,
    VT_UNIFORMS = 6
  };
  uint32_t MATERIAL_TYPE_ID() const {
    return GetField<uint32_t>(VT_MATERIAL_TYPE_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>> *UNIFORMs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>> *>(VT_UNIFORMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MATERIAL_TYPE_ID) &&
           VerifyOffset(verifier, VT_UNIFORMS) &&
           verifier.VerifyVector(UNIFORMs()) &&
           verifier.VerifyVectorOfTables(UNIFORMs()) &&
           verifier.EndTable();
  }
};

struct MATERIAL_INSTANCEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MATERIAL_TYPE_ID(uint32_t MATERIAL_TYPE_ID) {
    fbb_.AddElement<uint32_t>(MATERIAL_INSTANCE::VT_MATERIAL_TYPE_ID, MATERIAL_TYPE_ID, 0);
  }
  void add_UNIFORMs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>>> UNIFORMs) {
    fbb_.AddOffset(MATERIAL_INSTANCE::VT_UNIFORMS, UNIFORMs);
  }
  explicit MATERIAL_INSTANCEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MATERIAL_INSTANCEBuilder &operator=(const MATERIAL_INSTANCEBuilder &);
  flatbuffers::Offset<MATERIAL_INSTANCE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MATERIAL_INSTANCE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MATERIAL_INSTANCE> CreateMATERIAL_INSTANCE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t MATERIAL_TYPE_ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>>> UNIFORMs = 0) {
  MATERIAL_INSTANCEBuilder builder_(_fbb);
  builder_.add_UNIFORMs(UNIFORMs);
  builder_.add_MATERIAL_TYPE_ID(MATERIAL_TYPE_ID);
  return builder_.Finish();
}

inline flatbuffers::Offset<MATERIAL_INSTANCE> CreateMATERIAL_INSTANCEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t MATERIAL_TYPE_ID = 0,
    const std::vector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>> *UNIFORMs = nullptr) {
  auto UNIFORMs__ = UNIFORMs ? _fbb.CreateVector<flatbuffers::Offset<GFXAsset::MATERIAL_INSTANCE_UNIFORM_TABLE>>(*UNIFORMs) : 0;
  return GFXAsset::CreateMATERIAL_INSTANCE(
      _fbb,
      MATERIAL_TYPE_ID,
      UNIFORMs__);
}

struct TEXTURE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_DATA = 8,
    VT_DIMENSION = 10,
    VT_CHANNELS = 12,
    VT_VALUE_TYPE = 14,
    VT_MIPMAP_FILTERING = 16,
    VT_WRAPPING = 18
  };
  uint32_t WIDTH() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t HEIGHT() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<uint8_t> *DATA() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  GFXAsset::TEXTURE_DIMENSION DIMENSION() const {
    return static_cast<GFXAsset::TEXTURE_DIMENSION>(GetField<uint8_t>(VT_DIMENSION, 0));
  }
  GFXAsset::TEXTURE_CHANNELs CHANNELs() const {
    return static_cast<GFXAsset::TEXTURE_CHANNELs>(GetField<uint8_t>(VT_CHANNELS, 0));
  }
  GFXAsset::TEXTURE_VALUETYPE VALUE_TYPE() const {
    return static_cast<GFXAsset::TEXTURE_VALUETYPE>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  GFXAsset::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING() const {
    return static_cast<GFXAsset::TEXTURE_MIPMAP_FILTERING>(GetField<uint8_t>(VT_MIPMAP_FILTERING, 0));
  }
  GFXAsset::TEXTURE_WRAPPING WRAPPING() const {
    return static_cast<GFXAsset::TEXTURE_WRAPPING>(GetField<uint8_t>(VT_WRAPPING, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           VerifyField<uint8_t>(verifier, VT_DIMENSION) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELS) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_MIPMAP_FILTERING) &&
           VerifyField<uint8_t>(verifier, VT_WRAPPING) &&
           verifier.EndTable();
  }
};

struct TEXTUREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_WIDTH(uint32_t WIDTH) {
    fbb_.AddElement<uint32_t>(TEXTURE::VT_WIDTH, WIDTH, 0);
  }
  void add_HEIGHT(uint32_t HEIGHT) {
    fbb_.AddElement<uint32_t>(TEXTURE::VT_HEIGHT, HEIGHT, 0);
  }
  void add_DATA(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> DATA) {
    fbb_.AddOffset(TEXTURE::VT_DATA, DATA);
  }
  void add_DIMENSION(GFXAsset::TEXTURE_DIMENSION DIMENSION) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_DIMENSION, static_cast<uint8_t>(DIMENSION), 0);
  }
  void add_CHANNELs(GFXAsset::TEXTURE_CHANNELs CHANNELs) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_CHANNELS, static_cast<uint8_t>(CHANNELs), 0);
  }
  void add_VALUE_TYPE(GFXAsset::TEXTURE_VALUETYPE VALUE_TYPE) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_VALUE_TYPE, static_cast<uint8_t>(VALUE_TYPE), 0);
  }
  void add_MIPMAP_FILTERING(GFXAsset::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_MIPMAP_FILTERING, static_cast<uint8_t>(MIPMAP_FILTERING), 0);
  }
  void add_WRAPPING(GFXAsset::TEXTURE_WRAPPING WRAPPING) {
    fbb_.AddElement<uint8_t>(TEXTURE::VT_WRAPPING, static_cast<uint8_t>(WRAPPING), 0);
  }
  explicit TEXTUREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TEXTUREBuilder &operator=(const TEXTUREBuilder &);
  flatbuffers::Offset<TEXTURE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TEXTURE>(end);
    return o;
  }
};

inline flatbuffers::Offset<TEXTURE> CreateTEXTURE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t WIDTH = 0,
    uint32_t HEIGHT = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> DATA = 0,
    GFXAsset::TEXTURE_DIMENSION DIMENSION = GFXAsset::TEXTURE_DIMENSION_TEXTURE_2D,
    GFXAsset::TEXTURE_CHANNELs CHANNELs = GFXAsset::TEXTURE_CHANNELs_TEXTURE_RGB,
    GFXAsset::TEXTURE_VALUETYPE VALUE_TYPE = GFXAsset::TEXTURE_VALUETYPE_UBYTE8,
    GFXAsset::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING = GFXAsset::TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
    GFXAsset::TEXTURE_WRAPPING WRAPPING = GFXAsset::TEXTURE_WRAPPING_REPEAT) {
  TEXTUREBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_HEIGHT(HEIGHT);
  builder_.add_WIDTH(WIDTH);
  builder_.add_WRAPPING(WRAPPING);
  builder_.add_MIPMAP_FILTERING(MIPMAP_FILTERING);
  builder_.add_VALUE_TYPE(VALUE_TYPE);
  builder_.add_CHANNELs(CHANNELs);
  builder_.add_DIMENSION(DIMENSION);
  return builder_.Finish();
}

inline flatbuffers::Offset<TEXTURE> CreateTEXTUREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t WIDTH = 0,
    uint32_t HEIGHT = 0,
    const std::vector<uint8_t> *DATA = nullptr,
    GFXAsset::TEXTURE_DIMENSION DIMENSION = GFXAsset::TEXTURE_DIMENSION_TEXTURE_2D,
    GFXAsset::TEXTURE_CHANNELs CHANNELs = GFXAsset::TEXTURE_CHANNELs_TEXTURE_RGB,
    GFXAsset::TEXTURE_VALUETYPE VALUE_TYPE = GFXAsset::TEXTURE_VALUETYPE_UBYTE8,
    GFXAsset::TEXTURE_MIPMAP_FILTERING MIPMAP_FILTERING = GFXAsset::TEXTURE_MIPMAP_FILTERING_LINEAR_FROM_1MIP,
    GFXAsset::TEXTURE_WRAPPING WRAPPING = GFXAsset::TEXTURE_WRAPPING_REPEAT) {
  auto DATA__ = DATA ? _fbb.CreateVector<uint8_t>(*DATA) : 0;
  return GFXAsset::CreateTEXTURE(
      _fbb,
      WIDTH,
      HEIGHT,
      DATA__,
      DIMENSION,
      CHANNELs,
      VALUE_TYPE,
      MIPMAP_FILTERING,
      WRAPPING);
}

struct Resource FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6
  };
  GFXAsset::Resource_Type TYPE_type() const {
    return static_cast<GFXAsset::Resource_Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *TYPE() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *TYPE_as() const;
  const GFXAsset::SHADERSOURCE *TYPE_as_Shader_Source() const {
    return TYPE_type() == GFXAsset::Resource_Type_Shader_Source ? static_cast<const GFXAsset::SHADERSOURCE *>(TYPE()) : nullptr;
  }
  const GFXAsset::MATERIAL_TYPE *TYPE_as_Material_Type() const {
    return TYPE_type() == GFXAsset::Resource_Type_Material_Type ? static_cast<const GFXAsset::MATERIAL_TYPE *>(TYPE()) : nullptr;
  }
  const GFXAsset::MATERIAL_INSTANCE *TYPE_as_Material_Instance() const {
    return TYPE_type() == GFXAsset::Resource_Type_Material_Instance ? static_cast<const GFXAsset::MATERIAL_INSTANCE *>(TYPE()) : nullptr;
  }
  const GFXAsset::TEXTURE *TYPE_as_Texture() const {
    return TYPE_type() == GFXAsset::Resource_Type_Texture ? static_cast<const GFXAsset::TEXTURE *>(TYPE()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyResource_Type(verifier, TYPE(), TYPE_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GFXAsset::SHADERSOURCE *Resource::TYPE_as<GFXAsset::SHADERSOURCE>() const {
  return TYPE_as_Shader_Source();
}

template<> inline const GFXAsset::MATERIAL_TYPE *Resource::TYPE_as<GFXAsset::MATERIAL_TYPE>() const {
  return TYPE_as_Material_Type();
}

template<> inline const GFXAsset::MATERIAL_INSTANCE *Resource::TYPE_as<GFXAsset::MATERIAL_INSTANCE>() const {
  return TYPE_as_Material_Instance();
}

template<> inline const GFXAsset::TEXTURE *Resource::TYPE_as<GFXAsset::TEXTURE>() const {
  return TYPE_as_Texture();
}

struct ResourceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TYPE_type(GFXAsset::Resource_Type TYPE_type) {
    fbb_.AddElement<uint8_t>(Resource::VT_TYPE_TYPE, static_cast<uint8_t>(TYPE_type), 0);
  }
  void add_TYPE(flatbuffers::Offset<void> TYPE) {
    fbb_.AddOffset(Resource::VT_TYPE, TYPE);
  }
  explicit ResourceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceBuilder &operator=(const ResourceBuilder &);
  flatbuffers::Offset<Resource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resource>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resource> CreateResource(
    flatbuffers::FlatBufferBuilder &_fbb,
    GFXAsset::Resource_Type TYPE_type = GFXAsset::Resource_Type_NONE,
    flatbuffers::Offset<void> TYPE = 0) {
  ResourceBuilder builder_(_fbb);
  builder_.add_TYPE(TYPE);
  builder_.add_TYPE_type(TYPE_type);
  return builder_.Finish();
}

inline bool VerifyMATERIAL_INSTANCE_UNIFORM(flatbuffers::Verifier &verifier, const void *obj, MATERIAL_INSTANCE_UNIFORM type) {
  switch (type) {
    case MATERIAL_INSTANCE_UNIFORM_NONE: {
      return true;
    }
    case MATERIAL_INSTANCE_UNIFORM_UINT32: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_UINT32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_INT32: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_INT32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_FLOAT: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_FLOAT *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_VEC2: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_VEC2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_VEC3: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_VEC3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_VEC4: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_VEC4 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_Mat4x4: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_MAT4x4 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MATERIAL_INSTANCE_UNIFORM_TEXTURE2D: {
      auto ptr = reinterpret_cast<const GFXAsset::UNIFORM_TEXTURE2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMATERIAL_INSTANCE_UNIFORMVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMATERIAL_INSTANCE_UNIFORM(
        verifier,  values->Get(i), types->GetEnum<MATERIAL_INSTANCE_UNIFORM>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type) {
  switch (type) {
    case Resource_Type_NONE: {
      return true;
    }
    case Resource_Type_Shader_Source: {
      auto ptr = reinterpret_cast<const GFXAsset::SHADERSOURCE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Material_Type: {
      auto ptr = reinterpret_cast<const GFXAsset::MATERIAL_TYPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Material_Instance: {
      auto ptr = reinterpret_cast<const GFXAsset::MATERIAL_INSTANCE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Texture: {
      auto ptr = reinterpret_cast<const GFXAsset::TEXTURE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResource_Type(
        verifier,  values->Get(i), types->GetEnum<Resource_Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const GFXAsset::Resource *GetResource(const void *buf) {
  return flatbuffers::GetRoot<GFXAsset::Resource>(buf);
}

inline const GFXAsset::Resource *GetSizePrefixedResource(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<GFXAsset::Resource>(buf);
}

inline bool VerifyResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GFXAsset::Resource>(nullptr);
}

inline bool VerifySizePrefixedResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GFXAsset::Resource>(nullptr);
}

inline void FinishResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GFXAsset::Resource> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GFXAsset::Resource> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace GFXAsset

#endif  // FLATBUFFERS_GENERATED_GFXAPIRESOURCES_GFXASSET_H_

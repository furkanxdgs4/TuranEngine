// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EDITORRESOURCES_EDITORASSET_H_
#define FLATBUFFERS_GENERATED_EDITORRESOURCES_EDITORASSET_H_

#include "flatbuffers/flatbuffers.h"

namespace EditorAsset {

struct Vec2;

struct Vec3;

struct Vec4;

struct Mat4x4;

struct VERTEX_ATTRIBUTE;

struct MESH;

struct STATIC_MODEL;

struct StaticModel_ComponentTable;

struct Camera_ComponentTable;

struct GameComponent;

struct SCENE;

struct File;

struct FileList;

struct Resource;

enum ATTRIBUTE_DATATYPE {
  ATTRIBUTE_DATATYPE_UBYTE8 = 0,
  ATTRIBUTE_DATATYPE_BYTE8 = 1,
  ATTRIBUTE_DATATYPE_UINT32 = 2,
  ATTRIBUTE_DATATYPE_INT32 = 3,
  ATTRIBUTE_DATATYPE_FLOAT32 = 4,
  ATTRIBUTE_DATATYPE_VEC2 = 5,
  ATTRIBUTE_DATATYPE_VEC3 = 6,
  ATTRIBUTE_DATATYPE_VEC4 = 7,
  ATTRIBUTE_DATATYPE_MIN = ATTRIBUTE_DATATYPE_UBYTE8,
  ATTRIBUTE_DATATYPE_MAX = ATTRIBUTE_DATATYPE_VEC4
};

inline const ATTRIBUTE_DATATYPE (&EnumValuesATTRIBUTE_DATATYPE())[8] {
  static const ATTRIBUTE_DATATYPE values[] = {
    ATTRIBUTE_DATATYPE_UBYTE8,
    ATTRIBUTE_DATATYPE_BYTE8,
    ATTRIBUTE_DATATYPE_UINT32,
    ATTRIBUTE_DATATYPE_INT32,
    ATTRIBUTE_DATATYPE_FLOAT32,
    ATTRIBUTE_DATATYPE_VEC2,
    ATTRIBUTE_DATATYPE_VEC3,
    ATTRIBUTE_DATATYPE_VEC4
  };
  return values;
}

inline const char * const *EnumNamesATTRIBUTE_DATATYPE() {
  static const char * const names[9] = {
    "UBYTE8",
    "BYTE8",
    "UINT32",
    "INT32",
    "FLOAT32",
    "VEC2",
    "VEC3",
    "VEC4",
    nullptr
  };
  return names;
}

inline const char *EnumNameATTRIBUTE_DATATYPE(ATTRIBUTE_DATATYPE e) {
  if (e < ATTRIBUTE_DATATYPE_UBYTE8 || e > ATTRIBUTE_DATATYPE_VEC4) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesATTRIBUTE_DATATYPE()[index];
}

enum GameComponent_Type {
  GameComponent_Type_NONE = 0,
  GameComponent_Type_StaticModel_Component = 1,
  GameComponent_Type_Camera_Component = 2,
  GameComponent_Type_MIN = GameComponent_Type_NONE,
  GameComponent_Type_MAX = GameComponent_Type_Camera_Component
};

inline const GameComponent_Type (&EnumValuesGameComponent_Type())[3] {
  static const GameComponent_Type values[] = {
    GameComponent_Type_NONE,
    GameComponent_Type_StaticModel_Component,
    GameComponent_Type_Camera_Component
  };
  return values;
}

inline const char * const *EnumNamesGameComponent_Type() {
  static const char * const names[4] = {
    "NONE",
    "StaticModel_Component",
    "Camera_Component",
    nullptr
  };
  return names;
}

inline const char *EnumNameGameComponent_Type(GameComponent_Type e) {
  if (e < GameComponent_Type_NONE || e > GameComponent_Type_Camera_Component) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGameComponent_Type()[index];
}

template<typename T> struct GameComponent_TypeTraits {
  static const GameComponent_Type enum_value = GameComponent_Type_NONE;
};

template<> struct GameComponent_TypeTraits<EditorAsset::StaticModel_ComponentTable> {
  static const GameComponent_Type enum_value = GameComponent_Type_StaticModel_Component;
};

template<> struct GameComponent_TypeTraits<EditorAsset::Camera_ComponentTable> {
  static const GameComponent_Type enum_value = GameComponent_Type_Camera_Component;
};

bool VerifyGameComponent_Type(flatbuffers::Verifier &verifier, const void *obj, GameComponent_Type type);
bool VerifyGameComponent_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum File_Type {
  File_Type_ERROR = 0,
  File_Type_Material_Type = 1,
  File_Type_Material_Instance = 2,
  File_Type_Texture = 3,
  File_Type_Static_Model = 4,
  File_Type_Scene = 5,
  File_Type_ShaderSource = 6,
  File_Type_MIN = File_Type_ERROR,
  File_Type_MAX = File_Type_ShaderSource
};

inline const File_Type (&EnumValuesFile_Type())[7] {
  static const File_Type values[] = {
    File_Type_ERROR,
    File_Type_Material_Type,
    File_Type_Material_Instance,
    File_Type_Texture,
    File_Type_Static_Model,
    File_Type_Scene,
    File_Type_ShaderSource
  };
  return values;
}

inline const char * const *EnumNamesFile_Type() {
  static const char * const names[8] = {
    "ERROR",
    "Material_Type",
    "Material_Instance",
    "Texture",
    "Static_Model",
    "Scene",
    "ShaderSource",
    nullptr
  };
  return names;
}

inline const char *EnumNameFile_Type(File_Type e) {
  if (e < File_Type_ERROR || e > File_Type_ShaderSource) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFile_Type()[index];
}

enum Resource_Type {
  Resource_Type_NONE = 0,
  Resource_Type_Scene = 1,
  Resource_Type_File_List = 2,
  Resource_Type_Static_Model = 3,
  Resource_Type_MIN = Resource_Type_NONE,
  Resource_Type_MAX = Resource_Type_Static_Model
};

inline const Resource_Type (&EnumValuesResource_Type())[4] {
  static const Resource_Type values[] = {
    Resource_Type_NONE,
    Resource_Type_Scene,
    Resource_Type_File_List,
    Resource_Type_Static_Model
  };
  return values;
}

inline const char * const *EnumNamesResource_Type() {
  static const char * const names[5] = {
    "NONE",
    "Scene",
    "File_List",
    "Static_Model",
    nullptr
  };
  return names;
}

inline const char *EnumNameResource_Type(Resource_Type e) {
  if (e < Resource_Type_NONE || e > Resource_Type_Static_Model) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResource_Type()[index];
}

template<typename T> struct Resource_TypeTraits {
  static const Resource_Type enum_value = Resource_Type_NONE;
};

template<> struct Resource_TypeTraits<EditorAsset::SCENE> {
  static const Resource_Type enum_value = Resource_Type_Scene;
};

template<> struct Resource_TypeTraits<EditorAsset::FileList> {
  static const Resource_Type enum_value = Resource_Type_File_List;
};

template<> struct Resource_TypeTraits<EditorAsset::STATIC_MODEL> {
  static const Resource_Type enum_value = Resource_Type_Static_Model;
};

bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type);
bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4x4 FLATBUFFERS_FINAL_CLASS {
 private:
  EditorAsset::Vec4 ROW_1_;
  EditorAsset::Vec4 ROW_2_;
  EditorAsset::Vec4 ROW_3_;
  EditorAsset::Vec4 ROW_4_;

 public:
  Mat4x4() {
    memset(static_cast<void *>(this), 0, sizeof(Mat4x4));
  }
  Mat4x4(const EditorAsset::Vec4 &_ROW_1, const EditorAsset::Vec4 &_ROW_2, const EditorAsset::Vec4 &_ROW_3, const EditorAsset::Vec4 &_ROW_4)
      : ROW_1_(_ROW_1),
        ROW_2_(_ROW_2),
        ROW_3_(_ROW_3),
        ROW_4_(_ROW_4) {
  }
  const EditorAsset::Vec4 &ROW_1() const {
    return ROW_1_;
  }
  const EditorAsset::Vec4 &ROW_2() const {
    return ROW_2_;
  }
  const EditorAsset::Vec4 &ROW_3() const {
    return ROW_3_;
  }
  const EditorAsset::Vec4 &ROW_4() const {
    return ROW_4_;
  }
};
FLATBUFFERS_STRUCT_END(Mat4x4, 64);

struct VERTEX_ATTRIBUTE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRIBUTENAME = 4,
    VT_DATATYPE = 6,
    VT_ATTRIBUTEINDEX = 8,
    VT_STRIDE = 10,
    VT_START_OFFSET = 12
  };
  const flatbuffers::String *AttributeName() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTRIBUTENAME);
  }
  EditorAsset::ATTRIBUTE_DATATYPE DataType() const {
    return static_cast<EditorAsset::ATTRIBUTE_DATATYPE>(GetField<uint8_t>(VT_DATATYPE, 0));
  }
  uint8_t AttributeIndex() const {
    return GetField<uint8_t>(VT_ATTRIBUTEINDEX, 0);
  }
  uint32_t Stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  uint32_t Start_Offset() const {
    return GetField<uint32_t>(VT_START_OFFSET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTENAME) &&
           verifier.VerifyString(AttributeName()) &&
           VerifyField<uint8_t>(verifier, VT_DATATYPE) &&
           VerifyField<uint8_t>(verifier, VT_ATTRIBUTEINDEX) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE) &&
           VerifyField<uint32_t>(verifier, VT_START_OFFSET) &&
           verifier.EndTable();
  }
};

struct VERTEX_ATTRIBUTEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AttributeName(flatbuffers::Offset<flatbuffers::String> AttributeName) {
    fbb_.AddOffset(VERTEX_ATTRIBUTE::VT_ATTRIBUTENAME, AttributeName);
  }
  void add_DataType(EditorAsset::ATTRIBUTE_DATATYPE DataType) {
    fbb_.AddElement<uint8_t>(VERTEX_ATTRIBUTE::VT_DATATYPE, static_cast<uint8_t>(DataType), 0);
  }
  void add_AttributeIndex(uint8_t AttributeIndex) {
    fbb_.AddElement<uint8_t>(VERTEX_ATTRIBUTE::VT_ATTRIBUTEINDEX, AttributeIndex, 0);
  }
  void add_Stride(uint32_t Stride) {
    fbb_.AddElement<uint32_t>(VERTEX_ATTRIBUTE::VT_STRIDE, Stride, 0);
  }
  void add_Start_Offset(uint32_t Start_Offset) {
    fbb_.AddElement<uint32_t>(VERTEX_ATTRIBUTE::VT_START_OFFSET, Start_Offset, 0);
  }
  explicit VERTEX_ATTRIBUTEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VERTEX_ATTRIBUTEBuilder &operator=(const VERTEX_ATTRIBUTEBuilder &);
  flatbuffers::Offset<VERTEX_ATTRIBUTE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VERTEX_ATTRIBUTE>(end);
    return o;
  }
};

inline flatbuffers::Offset<VERTEX_ATTRIBUTE> CreateVERTEX_ATTRIBUTE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> AttributeName = 0,
    EditorAsset::ATTRIBUTE_DATATYPE DataType = EditorAsset::ATTRIBUTE_DATATYPE_UBYTE8,
    uint8_t AttributeIndex = 0,
    uint32_t Stride = 0,
    uint32_t Start_Offset = 0) {
  VERTEX_ATTRIBUTEBuilder builder_(_fbb);
  builder_.add_Start_Offset(Start_Offset);
  builder_.add_Stride(Stride);
  builder_.add_AttributeName(AttributeName);
  builder_.add_AttributeIndex(AttributeIndex);
  builder_.add_DataType(DataType);
  return builder_.Finish();
}

inline flatbuffers::Offset<VERTEX_ATTRIBUTE> CreateVERTEX_ATTRIBUTEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *AttributeName = nullptr,
    EditorAsset::ATTRIBUTE_DATATYPE DataType = EditorAsset::ATTRIBUTE_DATATYPE_UBYTE8,
    uint8_t AttributeIndex = 0,
    uint32_t Stride = 0,
    uint32_t Start_Offset = 0) {
  auto AttributeName__ = AttributeName ? _fbb.CreateString(AttributeName) : 0;
  return EditorAsset::CreateVERTEX_ATTRIBUTE(
      _fbb,
      AttributeName__,
      DataType,
      AttributeIndex,
      Stride,
      Start_Offset);
}

struct MESH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_ATTRIBUTELAYOUT = 6,
    VT_MATERIAL_INDEX = 8,
    VT_VERTEXNUMBER = 10
  };
  const flatbuffers::Vector<int8_t> *DATA() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::VERTEX_ATTRIBUTE>> *AttributeLayout() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::VERTEX_ATTRIBUTE>> *>(VT_ATTRIBUTELAYOUT);
  }
  uint8_t Material_Index() const {
    return GetField<uint8_t>(VT_MATERIAL_INDEX, 0);
  }
  uint32_t VertexNumber() const {
    return GetField<uint32_t>(VT_VERTEXNUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           VerifyOffset(verifier, VT_ATTRIBUTELAYOUT) &&
           verifier.VerifyVector(AttributeLayout()) &&
           verifier.VerifyVectorOfTables(AttributeLayout()) &&
           VerifyField<uint8_t>(verifier, VT_MATERIAL_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_VERTEXNUMBER) &&
           verifier.EndTable();
  }
};

struct MESHBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DATA(flatbuffers::Offset<flatbuffers::Vector<int8_t>> DATA) {
    fbb_.AddOffset(MESH::VT_DATA, DATA);
  }
  void add_AttributeLayout(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::VERTEX_ATTRIBUTE>>> AttributeLayout) {
    fbb_.AddOffset(MESH::VT_ATTRIBUTELAYOUT, AttributeLayout);
  }
  void add_Material_Index(uint8_t Material_Index) {
    fbb_.AddElement<uint8_t>(MESH::VT_MATERIAL_INDEX, Material_Index, 0);
  }
  void add_VertexNumber(uint32_t VertexNumber) {
    fbb_.AddElement<uint32_t>(MESH::VT_VERTEXNUMBER, VertexNumber, 0);
  }
  explicit MESHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MESHBuilder &operator=(const MESHBuilder &);
  flatbuffers::Offset<MESH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MESH>(end);
    return o;
  }
};

inline flatbuffers::Offset<MESH> CreateMESH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> DATA = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::VERTEX_ATTRIBUTE>>> AttributeLayout = 0,
    uint8_t Material_Index = 0,
    uint32_t VertexNumber = 0) {
  MESHBuilder builder_(_fbb);
  builder_.add_VertexNumber(VertexNumber);
  builder_.add_AttributeLayout(AttributeLayout);
  builder_.add_DATA(DATA);
  builder_.add_Material_Index(Material_Index);
  return builder_.Finish();
}

inline flatbuffers::Offset<MESH> CreateMESHDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *DATA = nullptr,
    const std::vector<flatbuffers::Offset<EditorAsset::VERTEX_ATTRIBUTE>> *AttributeLayout = nullptr,
    uint8_t Material_Index = 0,
    uint32_t VertexNumber = 0) {
  auto DATA__ = DATA ? _fbb.CreateVector<int8_t>(*DATA) : 0;
  auto AttributeLayout__ = AttributeLayout ? _fbb.CreateVector<flatbuffers::Offset<EditorAsset::VERTEX_ATTRIBUTE>>(*AttributeLayout) : 0;
  return EditorAsset::CreateMESH(
      _fbb,
      DATA__,
      AttributeLayout__,
      Material_Index,
      VertexNumber);
}

struct STATIC_MODEL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESHES = 4,
    VT_MATERIAL_NUMBER = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::MESH>> *MESHes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::MESH>> *>(VT_MESHES);
  }
  uint8_t Material_Number() const {
    return GetField<uint8_t>(VT_MATERIAL_NUMBER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(MESHes()) &&
           verifier.VerifyVectorOfTables(MESHes()) &&
           VerifyField<uint8_t>(verifier, VT_MATERIAL_NUMBER) &&
           verifier.EndTable();
  }
};

struct STATIC_MODELBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MESHes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::MESH>>> MESHes) {
    fbb_.AddOffset(STATIC_MODEL::VT_MESHES, MESHes);
  }
  void add_Material_Number(uint8_t Material_Number) {
    fbb_.AddElement<uint8_t>(STATIC_MODEL::VT_MATERIAL_NUMBER, Material_Number, 0);
  }
  explicit STATIC_MODELBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  STATIC_MODELBuilder &operator=(const STATIC_MODELBuilder &);
  flatbuffers::Offset<STATIC_MODEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<STATIC_MODEL>(end);
    return o;
  }
};

inline flatbuffers::Offset<STATIC_MODEL> CreateSTATIC_MODEL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::MESH>>> MESHes = 0,
    uint8_t Material_Number = 0) {
  STATIC_MODELBuilder builder_(_fbb);
  builder_.add_MESHes(MESHes);
  builder_.add_Material_Number(Material_Number);
  return builder_.Finish();
}

inline flatbuffers::Offset<STATIC_MODEL> CreateSTATIC_MODELDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<EditorAsset::MESH>> *MESHes = nullptr,
    uint8_t Material_Number = 0) {
  auto MESHes__ = MESHes ? _fbb.CreateVector<flatbuffers::Offset<EditorAsset::MESH>>(*MESHes) : 0;
  return EditorAsset::CreateSTATIC_MODEL(
      _fbb,
      MESHes__,
      Material_Number);
}

struct StaticModel_ComponentTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MODEL_ID = 6,
    VT_MATERIALINSTANCES_IDS = 8,
    VT_LOCATION = 10,
    VT_ROTATION = 12,
    VT_SCALE = 14
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t Model_ID() const {
    return GetField<uint32_t>(VT_MODEL_ID, 0);
  }
  const flatbuffers::Vector<uint32_t> *MaterialInstances_IDs() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MATERIALINSTANCES_IDS);
  }
  const EditorAsset::Vec3 *LOCATION() const {
    return GetStruct<const EditorAsset::Vec3 *>(VT_LOCATION);
  }
  const EditorAsset::Vec3 *ROTATION() const {
    return GetStruct<const EditorAsset::Vec3 *>(VT_ROTATION);
  }
  const EditorAsset::Vec3 *SCALE() const {
    return GetStruct<const EditorAsset::Vec3 *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint32_t>(verifier, VT_MODEL_ID) &&
           VerifyOffset(verifier, VT_MATERIALINSTANCES_IDS) &&
           verifier.VerifyVector(MaterialInstances_IDs()) &&
           VerifyField<EditorAsset::Vec3>(verifier, VT_LOCATION) &&
           VerifyField<EditorAsset::Vec3>(verifier, VT_ROTATION) &&
           VerifyField<EditorAsset::Vec3>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct StaticModel_ComponentTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(StaticModel_ComponentTable::VT_NAME, NAME);
  }
  void add_Model_ID(uint32_t Model_ID) {
    fbb_.AddElement<uint32_t>(StaticModel_ComponentTable::VT_MODEL_ID, Model_ID, 0);
  }
  void add_MaterialInstances_IDs(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> MaterialInstances_IDs) {
    fbb_.AddOffset(StaticModel_ComponentTable::VT_MATERIALINSTANCES_IDS, MaterialInstances_IDs);
  }
  void add_LOCATION(const EditorAsset::Vec3 *LOCATION) {
    fbb_.AddStruct(StaticModel_ComponentTable::VT_LOCATION, LOCATION);
  }
  void add_ROTATION(const EditorAsset::Vec3 *ROTATION) {
    fbb_.AddStruct(StaticModel_ComponentTable::VT_ROTATION, ROTATION);
  }
  void add_SCALE(const EditorAsset::Vec3 *SCALE) {
    fbb_.AddStruct(StaticModel_ComponentTable::VT_SCALE, SCALE);
  }
  explicit StaticModel_ComponentTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StaticModel_ComponentTableBuilder &operator=(const StaticModel_ComponentTableBuilder &);
  flatbuffers::Offset<StaticModel_ComponentTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StaticModel_ComponentTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<StaticModel_ComponentTable> CreateStaticModel_ComponentTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    uint32_t Model_ID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> MaterialInstances_IDs = 0,
    const EditorAsset::Vec3 *LOCATION = 0,
    const EditorAsset::Vec3 *ROTATION = 0,
    const EditorAsset::Vec3 *SCALE = 0) {
  StaticModel_ComponentTableBuilder builder_(_fbb);
  builder_.add_SCALE(SCALE);
  builder_.add_ROTATION(ROTATION);
  builder_.add_LOCATION(LOCATION);
  builder_.add_MaterialInstances_IDs(MaterialInstances_IDs);
  builder_.add_Model_ID(Model_ID);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<StaticModel_ComponentTable> CreateStaticModel_ComponentTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint32_t Model_ID = 0,
    const std::vector<uint32_t> *MaterialInstances_IDs = nullptr,
    const EditorAsset::Vec3 *LOCATION = 0,
    const EditorAsset::Vec3 *ROTATION = 0,
    const EditorAsset::Vec3 *SCALE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto MaterialInstances_IDs__ = MaterialInstances_IDs ? _fbb.CreateVector<uint32_t>(*MaterialInstances_IDs) : 0;
  return EditorAsset::CreateStaticModel_ComponentTable(
      _fbb,
      NAME__,
      Model_ID,
      MaterialInstances_IDs__,
      LOCATION,
      ROTATION,
      SCALE);
}

struct Camera_ComponentTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LOCATION = 6,
    VT_FOV_INANGLE = 8,
    VT_ASPECT_WIDTH = 10,
    VT_ASPECT_HEIGHT = 12,
    VT_NEAR_PLANE = 14,
    VT_FAR_PLANE = 16,
    VT_TARGET = 18
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const EditorAsset::Vec3 *LOCATION() const {
    return GetStruct<const EditorAsset::Vec3 *>(VT_LOCATION);
  }
  uint16_t FOV_inAngle() const {
    return GetField<uint16_t>(VT_FOV_INANGLE, 0);
  }
  uint16_t Aspect_WIDTH() const {
    return GetField<uint16_t>(VT_ASPECT_WIDTH, 0);
  }
  uint16_t Aspect_HEIGHT() const {
    return GetField<uint16_t>(VT_ASPECT_HEIGHT, 0);
  }
  float Near_Plane() const {
    return GetField<float>(VT_NEAR_PLANE, 0.0f);
  }
  float Far_Plane() const {
    return GetField<float>(VT_FAR_PLANE, 0.0f);
  }
  const EditorAsset::Vec3 *Target() const {
    return GetStruct<const EditorAsset::Vec3 *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<EditorAsset::Vec3>(verifier, VT_LOCATION) &&
           VerifyField<uint16_t>(verifier, VT_FOV_INANGLE) &&
           VerifyField<uint16_t>(verifier, VT_ASPECT_WIDTH) &&
           VerifyField<uint16_t>(verifier, VT_ASPECT_HEIGHT) &&
           VerifyField<float>(verifier, VT_NEAR_PLANE) &&
           VerifyField<float>(verifier, VT_FAR_PLANE) &&
           VerifyField<EditorAsset::Vec3>(verifier, VT_TARGET) &&
           verifier.EndTable();
  }
};

struct Camera_ComponentTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(Camera_ComponentTable::VT_NAME, NAME);
  }
  void add_LOCATION(const EditorAsset::Vec3 *LOCATION) {
    fbb_.AddStruct(Camera_ComponentTable::VT_LOCATION, LOCATION);
  }
  void add_FOV_inAngle(uint16_t FOV_inAngle) {
    fbb_.AddElement<uint16_t>(Camera_ComponentTable::VT_FOV_INANGLE, FOV_inAngle, 0);
  }
  void add_Aspect_WIDTH(uint16_t Aspect_WIDTH) {
    fbb_.AddElement<uint16_t>(Camera_ComponentTable::VT_ASPECT_WIDTH, Aspect_WIDTH, 0);
  }
  void add_Aspect_HEIGHT(uint16_t Aspect_HEIGHT) {
    fbb_.AddElement<uint16_t>(Camera_ComponentTable::VT_ASPECT_HEIGHT, Aspect_HEIGHT, 0);
  }
  void add_Near_Plane(float Near_Plane) {
    fbb_.AddElement<float>(Camera_ComponentTable::VT_NEAR_PLANE, Near_Plane, 0.0f);
  }
  void add_Far_Plane(float Far_Plane) {
    fbb_.AddElement<float>(Camera_ComponentTable::VT_FAR_PLANE, Far_Plane, 0.0f);
  }
  void add_Target(const EditorAsset::Vec3 *Target) {
    fbb_.AddStruct(Camera_ComponentTable::VT_TARGET, Target);
  }
  explicit Camera_ComponentTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Camera_ComponentTableBuilder &operator=(const Camera_ComponentTableBuilder &);
  flatbuffers::Offset<Camera_ComponentTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Camera_ComponentTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Camera_ComponentTable> CreateCamera_ComponentTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    const EditorAsset::Vec3 *LOCATION = 0,
    uint16_t FOV_inAngle = 0,
    uint16_t Aspect_WIDTH = 0,
    uint16_t Aspect_HEIGHT = 0,
    float Near_Plane = 0.0f,
    float Far_Plane = 0.0f,
    const EditorAsset::Vec3 *Target = 0) {
  Camera_ComponentTableBuilder builder_(_fbb);
  builder_.add_Target(Target);
  builder_.add_Far_Plane(Far_Plane);
  builder_.add_Near_Plane(Near_Plane);
  builder_.add_LOCATION(LOCATION);
  builder_.add_NAME(NAME);
  builder_.add_Aspect_HEIGHT(Aspect_HEIGHT);
  builder_.add_Aspect_WIDTH(Aspect_WIDTH);
  builder_.add_FOV_inAngle(FOV_inAngle);
  return builder_.Finish();
}

inline flatbuffers::Offset<Camera_ComponentTable> CreateCamera_ComponentTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const EditorAsset::Vec3 *LOCATION = 0,
    uint16_t FOV_inAngle = 0,
    uint16_t Aspect_WIDTH = 0,
    uint16_t Aspect_HEIGHT = 0,
    float Near_Plane = 0.0f,
    float Far_Plane = 0.0f,
    const EditorAsset::Vec3 *Target = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return EditorAsset::CreateCamera_ComponentTable(
      _fbb,
      NAME__,
      LOCATION,
      FOV_inAngle,
      Aspect_WIDTH,
      Aspect_HEIGHT,
      Near_Plane,
      Far_Plane,
      Target);
}

struct GameComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENT_TYPE = 4,
    VT_COMPONENT = 6
  };
  EditorAsset::GameComponent_Type COMPONENT_type() const {
    return static_cast<EditorAsset::GameComponent_Type>(GetField<uint8_t>(VT_COMPONENT_TYPE, 0));
  }
  const void *COMPONENT() const {
    return GetPointer<const void *>(VT_COMPONENT);
  }
  template<typename T> const T *COMPONENT_as() const;
  const EditorAsset::StaticModel_ComponentTable *COMPONENT_as_StaticModel_Component() const {
    return COMPONENT_type() == EditorAsset::GameComponent_Type_StaticModel_Component ? static_cast<const EditorAsset::StaticModel_ComponentTable *>(COMPONENT()) : nullptr;
  }
  const EditorAsset::Camera_ComponentTable *COMPONENT_as_Camera_Component() const {
    return COMPONENT_type() == EditorAsset::GameComponent_Type_Camera_Component ? static_cast<const EditorAsset::Camera_ComponentTable *>(COMPONENT()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMPONENT_TYPE) &&
           VerifyOffset(verifier, VT_COMPONENT) &&
           VerifyGameComponent_Type(verifier, COMPONENT(), COMPONENT_type()) &&
           verifier.EndTable();
  }
};

template<> inline const EditorAsset::StaticModel_ComponentTable *GameComponent::COMPONENT_as<EditorAsset::StaticModel_ComponentTable>() const {
  return COMPONENT_as_StaticModel_Component();
}

template<> inline const EditorAsset::Camera_ComponentTable *GameComponent::COMPONENT_as<EditorAsset::Camera_ComponentTable>() const {
  return COMPONENT_as_Camera_Component();
}

struct GameComponentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_COMPONENT_type(EditorAsset::GameComponent_Type COMPONENT_type) {
    fbb_.AddElement<uint8_t>(GameComponent::VT_COMPONENT_TYPE, static_cast<uint8_t>(COMPONENT_type), 0);
  }
  void add_COMPONENT(flatbuffers::Offset<void> COMPONENT) {
    fbb_.AddOffset(GameComponent::VT_COMPONENT, COMPONENT);
  }
  explicit GameComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameComponentBuilder &operator=(const GameComponentBuilder &);
  flatbuffers::Offset<GameComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameComponent> CreateGameComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    EditorAsset::GameComponent_Type COMPONENT_type = EditorAsset::GameComponent_Type_NONE,
    flatbuffers::Offset<void> COMPONENT = 0) {
  GameComponentBuilder builder_(_fbb);
  builder_.add_COMPONENT(COMPONENT);
  builder_.add_COMPONENT_type(COMPONENT_type);
  return builder_.Finish();
}

struct SCENE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMPONENTS = 6
  };
  const flatbuffers::String *NAME() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::GameComponent>> *COMPONENTs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::GameComponent>> *>(VT_COMPONENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(COMPONENTs()) &&
           verifier.VerifyVectorOfTables(COMPONENTs()) &&
           verifier.EndTable();
  }
};

struct SCENEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_NAME(flatbuffers::Offset<flatbuffers::String> NAME) {
    fbb_.AddOffset(SCENE::VT_NAME, NAME);
  }
  void add_COMPONENTs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::GameComponent>>> COMPONENTs) {
    fbb_.AddOffset(SCENE::VT_COMPONENTS, COMPONENTs);
  }
  explicit SCENEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SCENEBuilder &operator=(const SCENEBuilder &);
  flatbuffers::Offset<SCENE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SCENE>(end);
    return o;
  }
};

inline flatbuffers::Offset<SCENE> CreateSCENE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> NAME = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::GameComponent>>> COMPONENTs = 0) {
  SCENEBuilder builder_(_fbb);
  builder_.add_COMPONENTs(COMPONENTs);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline flatbuffers::Offset<SCENE> CreateSCENEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const std::vector<flatbuffers::Offset<EditorAsset::GameComponent>> *COMPONENTs = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto COMPONENTs__ = COMPONENTs ? _fbb.CreateVector<flatbuffers::Offset<EditorAsset::GameComponent>>(*COMPONENTs) : 0;
  return EditorAsset::CreateSCENE(
      _fbb,
      NAME__,
      COMPONENTs__);
}

struct File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_TYPE = 6,
    VT_ID = 8
  };
  const flatbuffers::String *PATH() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  EditorAsset::File_Type TYPE() const {
    return static_cast<EditorAsset::File_Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t ID() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(PATH()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct FileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_PATH(flatbuffers::Offset<flatbuffers::String> PATH) {
    fbb_.AddOffset(File::VT_PATH, PATH);
  }
  void add_TYPE(EditorAsset::File_Type TYPE) {
    fbb_.AddElement<uint8_t>(File::VT_TYPE, static_cast<uint8_t>(TYPE), 0);
  }
  void add_ID(uint32_t ID) {
    fbb_.AddElement<uint32_t>(File::VT_ID, ID, 0);
  }
  explicit FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileBuilder &operator=(const FileBuilder &);
  flatbuffers::Offset<File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File>(end);
    return o;
  }
};

inline flatbuffers::Offset<File> CreateFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> PATH = 0,
    EditorAsset::File_Type TYPE = EditorAsset::File_Type_ERROR,
    uint32_t ID = 0) {
  FileBuilder builder_(_fbb);
  builder_.add_ID(ID);
  builder_.add_PATH(PATH);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline flatbuffers::Offset<File> CreateFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *PATH = nullptr,
    EditorAsset::File_Type TYPE = EditorAsset::File_Type_ERROR,
    uint32_t ID = 0) {
  auto PATH__ = PATH ? _fbb.CreateString(PATH) : 0;
  return EditorAsset::CreateFile(
      _fbb,
      PATH__,
      TYPE,
      ID);
}

struct FileList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_LIST = 4,
    VT_LAST_ID = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::File>> *FILE_LIST() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EditorAsset::File>> *>(VT_FILE_LIST);
  }
  uint32_t LAST_ID() const {
    return GetField<uint32_t>(VT_LAST_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE_LIST) &&
           verifier.VerifyVector(FILE_LIST()) &&
           verifier.VerifyVectorOfTables(FILE_LIST()) &&
           VerifyField<uint32_t>(verifier, VT_LAST_ID) &&
           verifier.EndTable();
  }
};

struct FileListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FILE_LIST(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::File>>> FILE_LIST) {
    fbb_.AddOffset(FileList::VT_FILE_LIST, FILE_LIST);
  }
  void add_LAST_ID(uint32_t LAST_ID) {
    fbb_.AddElement<uint32_t>(FileList::VT_LAST_ID, LAST_ID, 0);
  }
  explicit FileListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileListBuilder &operator=(const FileListBuilder &);
  flatbuffers::Offset<FileList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileList>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileList> CreateFileList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EditorAsset::File>>> FILE_LIST = 0,
    uint32_t LAST_ID = 0) {
  FileListBuilder builder_(_fbb);
  builder_.add_LAST_ID(LAST_ID);
  builder_.add_FILE_LIST(FILE_LIST);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileList> CreateFileListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<EditorAsset::File>> *FILE_LIST = nullptr,
    uint32_t LAST_ID = 0) {
  auto FILE_LIST__ = FILE_LIST ? _fbb.CreateVector<flatbuffers::Offset<EditorAsset::File>>(*FILE_LIST) : 0;
  return EditorAsset::CreateFileList(
      _fbb,
      FILE_LIST__,
      LAST_ID);
}

struct Resource FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6
  };
  EditorAsset::Resource_Type TYPE_type() const {
    return static_cast<EditorAsset::Resource_Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *TYPE() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  template<typename T> const T *TYPE_as() const;
  const EditorAsset::SCENE *TYPE_as_Scene() const {
    return TYPE_type() == EditorAsset::Resource_Type_Scene ? static_cast<const EditorAsset::SCENE *>(TYPE()) : nullptr;
  }
  const EditorAsset::FileList *TYPE_as_File_List() const {
    return TYPE_type() == EditorAsset::Resource_Type_File_List ? static_cast<const EditorAsset::FileList *>(TYPE()) : nullptr;
  }
  const EditorAsset::STATIC_MODEL *TYPE_as_Static_Model() const {
    return TYPE_type() == EditorAsset::Resource_Type_Static_Model ? static_cast<const EditorAsset::STATIC_MODEL *>(TYPE()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyResource_Type(verifier, TYPE(), TYPE_type()) &&
           verifier.EndTable();
  }
};

template<> inline const EditorAsset::SCENE *Resource::TYPE_as<EditorAsset::SCENE>() const {
  return TYPE_as_Scene();
}

template<> inline const EditorAsset::FileList *Resource::TYPE_as<EditorAsset::FileList>() const {
  return TYPE_as_File_List();
}

template<> inline const EditorAsset::STATIC_MODEL *Resource::TYPE_as<EditorAsset::STATIC_MODEL>() const {
  return TYPE_as_Static_Model();
}

struct ResourceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TYPE_type(EditorAsset::Resource_Type TYPE_type) {
    fbb_.AddElement<uint8_t>(Resource::VT_TYPE_TYPE, static_cast<uint8_t>(TYPE_type), 0);
  }
  void add_TYPE(flatbuffers::Offset<void> TYPE) {
    fbb_.AddOffset(Resource::VT_TYPE, TYPE);
  }
  explicit ResourceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceBuilder &operator=(const ResourceBuilder &);
  flatbuffers::Offset<Resource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resource>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resource> CreateResource(
    flatbuffers::FlatBufferBuilder &_fbb,
    EditorAsset::Resource_Type TYPE_type = EditorAsset::Resource_Type_NONE,
    flatbuffers::Offset<void> TYPE = 0) {
  ResourceBuilder builder_(_fbb);
  builder_.add_TYPE(TYPE);
  builder_.add_TYPE_type(TYPE_type);
  return builder_.Finish();
}

inline bool VerifyGameComponent_Type(flatbuffers::Verifier &verifier, const void *obj, GameComponent_Type type) {
  switch (type) {
    case GameComponent_Type_NONE: {
      return true;
    }
    case GameComponent_Type_StaticModel_Component: {
      auto ptr = reinterpret_cast<const EditorAsset::StaticModel_ComponentTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GameComponent_Type_Camera_Component: {
      auto ptr = reinterpret_cast<const EditorAsset::Camera_ComponentTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyGameComponent_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGameComponent_Type(
        verifier,  values->Get(i), types->GetEnum<GameComponent_Type>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResource_Type(flatbuffers::Verifier &verifier, const void *obj, Resource_Type type) {
  switch (type) {
    case Resource_Type_NONE: {
      return true;
    }
    case Resource_Type_Scene: {
      auto ptr = reinterpret_cast<const EditorAsset::SCENE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_File_List: {
      auto ptr = reinterpret_cast<const EditorAsset::FileList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Resource_Type_Static_Model: {
      auto ptr = reinterpret_cast<const EditorAsset::STATIC_MODEL *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResource_TypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResource_Type(
        verifier,  values->Get(i), types->GetEnum<Resource_Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const EditorAsset::Resource *GetResource(const void *buf) {
  return flatbuffers::GetRoot<EditorAsset::Resource>(buf);
}

inline const EditorAsset::Resource *GetSizePrefixedResource(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EditorAsset::Resource>(buf);
}

inline bool VerifyResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EditorAsset::Resource>(nullptr);
}

inline bool VerifySizePrefixedResourceBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EditorAsset::Resource>(nullptr);
}

inline void FinishResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EditorAsset::Resource> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedResourceBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EditorAsset::Resource> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace EditorAsset

#endif  // FLATBUFFERS_GENERATED_EDITORRESOURCES_EDITORASSET_H_

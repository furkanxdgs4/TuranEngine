# TuranEngine
A game engine I was working in last summer, this winter break and will continue this summer. First development target is the Renderer and UI, then Game Object and ECS-Fiber Task systems. Only tested for Windows, but I think it is easy to port to other platforms using CMake or Premake. If you want to run the TuranEditor without compiling, open bin/TuranEditor/TuranEditor.exe.

# Refactoring Changes:
This refactoring was a need because I had lots of wrong decisions. The changes are in below as much as I can remember:

1) Logging system added to TuranAPI and have 5 types of logging. Crashing, HandledError, Warning, Status and Not Coded Path. There are 4 types of log files: Not Coded Paths, Errors, Warnings and All Logs. All of the logs are written to text files when a TuranAPI::LOG_CRASHING, a TuranAPI::LOG_NOTCODED(string, true) or application closed in IMGUI because logging per frame is costly operation with lots of log. And also TURAN_DEBUGGING macro is defined to build something with debugging purpose without going to Debugging mode of Visual Studio because my computer can't start the app in Debugging mode in 3 minutes.
2) I was having lots of trouble with Resource system because there were some empty created Resources etc. Now I have a Resource Verification progress for each Resource.
3) Instead of OpenGL3, I switched to OpenGL4 because OpenGL3 has lots of unnecessary limitations that would make RenderGraph architecture much much more complex and OpenGL4 has lots of feature set current devices (Mobile, Desktop, Console) have.
4) Instead of C++ Standard Library, I wrote my own little library. Vector, String and Bitset classes added. Vector works a little bit different than std version, so reading implementation is needed for user. String is so similar to std one, but it lacks some features (substr(), to_string() etc.), so I used std::string library when these features needed. Bitset is a Vector<bool> implementation, nothing more. Because of Bitset, Vector<bool> is not a specialized template class! Because I don't want to use std::string, I modified dear IMGUI to support my String class.
5) I wrote my own Memory Management system that uses one MemoryManager and some MemoryAllocators (currently one, multiples will be supported later!). Application allocates a big chunk of memory at start-up (defined in TuranAPI_Core.cpp) and gives some small chunks to MemoryAllocators. Because there is only one MemoryAllocator supported, it uses whole chunk. With using my own Memory Manager, I fixed the bugs in Vulkan project and drew my first triangle!
6) Dependencies between DLLs has gotten better, some DLL problems solved (static variable problems across DLLs), some compile-time optimizations has been done (more optimization is available, just done some of them).
7) FileSystem and IMGUI has changed. Material_Type, Material_Instance and Texture resources are moved to GFX_API; other are moved to TuranEditor. Because IMGUI's moved to GFX_API, relationship between renderer and IMGUI got better (IMGUI's gonna use GFX_TextureID to show a texture). All of the asset operations (Materials, Textures, Static Models, Scenes) are moved to TuranEditor's FileSystem and ID generation system got better (New generated ID will use a deleted asset's ID, if there is any). 
8) Created a GPUContentManager (Accessible via GFXContentManager macro) class that handles creating and deleting GPU objects (Mesh Buffer, Texture, Shaders, Framebuffer etc). It stores all object in GL specific structs with an ID. Vertex buffers, Framebuffers and RenderTargets uses a GFX_API ID (Because they are created by GPU); Textures, ShaderSources (Each shader stage) and ShaderPrograms (complete rasterization pipeline) uses Asset_ID (ID that's given by TuranEditor to store in Disk). A user can call GFXContentManager to upload a texture, store the returned ID and use it in GFX function calls. Because I store all objects with info about object (Texture struct with texture's width and height), user is able to get object's infos later but not coded yet (I'm just gonna return const reference of struct).
9) Relationship between RenderGraph and Draw Pass got better. Draw Pass can inform RenderGraph about what type of Render Targets it needs and RenderGraph can give them at RenderGraph_SetupPhase. Then each frame, RenderGraph's DrawCallBuffer is filled up and because we gave buffer's pointer to Draw Pass at creation, draw pass can choose which draw calls it should render and pass them to its own DrawCallBuffer. A Draw Call contains a DrawPassBitMask, a MeshBuffer_ID and a MaterialInstance_ID. Additional elements in rendering (cameras, particle effects etc.) is represented by a RenderingComponent. Because they are generally uploaded as a buffer and proccessed in some Compute, then rendered with Draw, I want Editor's user to be able to write his own rendering RenderingComponent and pass them to GPU as he wants. Sending a buffer to GPU should return a GFX_ID and user should use this ID in other operations (Camera's matrix buffer is uploaded and returned ID is given to MainDrawPass (or material instance, I didn't figure it out yet) to render things!).
10) Renderer will be responsible to convert each command to a graphics backend specific command. I will use Renderer->Draw in Draw Pass but Renderer will use DrawElements in OpenGL4, in Vulkan it should create GraphicsPipeline first, bind it then Draw etc. But Renderer will use a Thread-Safe Rendering State structure, that stores active framebuffer active shader instance etc. These are important for Vulkan, because we need all of these to create a GraphicsPipeline.

# Not-Refactored Yet:
1) Scene and Material resources have to have a better creation and modification editors, they don't work now! Because all rendering architecture is changed, material system should be supported better! I should code each Shader Stage (Vertex, Fragment etc) in Editor (or use the previously created ones), I should specify all vertex attributes and UBOs in Editor, I should set Rasterization states of the Material_Type etc.
2) Logging and Profiling works but not much like what I imagined. I want to handle exceptions and write logs to files just before them (this way, I don't need to use VSDebugger every time); I want to store Logging infos in a better way and also want to see all memory and performance status in a Editor window.
3) As I wrote above, String is lack of lots of features and they are important. So I need to code them.
4) There are some bugs I noted, I should solve them. Also I should be able to create a MemoryAllocator in anywhere and use it later.
5) After rendering the first triangle, I didn't touch Vulkan so it doesn't compile right now. I should design it like OpenGL4.
